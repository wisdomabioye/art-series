<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="@wisdomabioye">
    <meta name="description" content="Art Series #045 - crystallization">
    <meta name="created" content="2025-12-08">
    <title>crystallization | Art Series #045</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        /**
         * Art Series #045
         * Title: crystallization
         * Author: @wisdomabioye
         * Created: 2025-12-08
         * Description: Crystals forming and growing with faceted surfaces, light refraction, and shimmer effects
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ============================================
        // MAIN ANIMATION CODE
        // ============================================

        const crystalPalettes = [
            { base: '#9B59B6', light: '#D4A5FF', dark: '#6C3483', glow: '#E8DAEF' }, // Amethyst
            { base: '#3498DB', light: '#AED6F1', dark: '#1A5276', glow: '#D6EAF8' }, // Sapphire
            { base: '#E74C3C', light: '#F5B7B1', dark: '#922B21', glow: '#FADBD8' }, // Ruby
            { base: '#2ECC71', light: '#ABEBC6', dark: '#196F3D', glow: '#D5F5E3' }, // Emerald
            { base: '#F39C12', light: '#FAD7A0', dark: '#9A7D0A', glow: '#FEF9E7' }, // Citrine
            { base: '#1ABC9C', light: '#A3E4D7', dark: '#0E6655', glow: '#D1F2EB' }, // Aquamarine
            { base: '#E91E63', light: '#F8BBD9', dark: '#880E4F', glow: '#FCE4EC' }, // Rose quartz
            { base: '#FFFFFF', light: '#FFFFFF', dark: '#BDC3C7', glow: '#F8F9F9' }, // Diamond
        ];

        let crystals = [];
        let sparkles = [];
        let time = 0;

        class Crystal {
            constructor(x, y, isCluster = false) {
                this.x = x;
                this.y = y;
                this.palette = crystalPalettes[Math.floor(Math.random() * crystalPalettes.length)];
                this.shards = [];
                this.growth = 0;
                this.growthSpeed = 0.003 + Math.random() * 0.004;
                this.shimmerOffset = Math.random() * Math.PI * 2;

                // Generate crystal shards
                const shardCount = isCluster ? 1 : 3 + Math.floor(Math.random() * 4);
                for (let i = 0; i < shardCount; i++) {
                    this.shards.push(this.createShard(i, shardCount));
                }
            }

            createShard(index, total) {
                const angleSpread = 0.8;
                const baseAngle = -Math.PI / 2;
                const angle = baseAngle + (index - (total - 1) / 2) * (angleSpread / total) + (Math.random() - 0.5) * 0.2;

                return {
                    angle,
                    length: 50 + Math.random() * 80,
                    width: 8 + Math.random() * 15,
                    facets: 4 + Math.floor(Math.random() * 3), // 4-6 facets
                    taper: 0.15 + Math.random() * 0.2,
                    offset: (Math.random() - 0.5) * 20,
                    growthDelay: index * 0.1
                };
            }

            update() {
                if (this.growth < 1) {
                    this.growth += this.growthSpeed;
                }
            }

            draw() {
                const shimmer = Math.sin(time * 3 + this.shimmerOffset) * 0.1 + 0.9;

                this.shards.forEach((shard, i) => {
                    const shardGrowth = Math.max(0, Math.min(1, (this.growth - shard.growthDelay) / (1 - shard.growthDelay)));
                    if (shardGrowth <= 0) return;

                    const length = shard.length * shardGrowth;
                    const width = shard.width * shardGrowth;

                    ctx.save();
                    ctx.translate(this.x + shard.offset, this.y);
                    ctx.rotate(shard.angle + Math.PI / 2);

                    // Draw crystal shard with facets
                    this.drawCrystalShard(length, width, shard.taper, shard.facets, shimmer);

                    ctx.restore();
                });

                // Add sparkles when fully grown
                if (this.growth > 0.8 && Math.random() < 0.02) {
                    const shard = this.shards[Math.floor(Math.random() * this.shards.length)];
                    const dist = Math.random() * shard.length * 0.8;
                    const sparkleX = this.x + shard.offset + Math.cos(shard.angle) * dist;
                    const sparkleY = this.y + Math.sin(shard.angle) * dist;
                    sparkles.push(new Sparkle(sparkleX, sparkleY, this.palette.glow));
                }
            }

            drawCrystalShard(length, width, taper, facets, shimmer) {
                const tipWidth = width * taper;

                // Main crystal body - left side
                const gradient1 = ctx.createLinearGradient(-width / 2, 0, width / 2, 0);
                gradient1.addColorStop(0, this.palette.dark);
                gradient1.addColorStop(0.3, this.palette.base);
                gradient1.addColorStop(0.7, this.palette.light);
                gradient1.addColorStop(1, this.palette.base);

                ctx.fillStyle = gradient1;
                ctx.globalAlpha = 0.9 * shimmer;

                // Draw main body
                ctx.beginPath();
                ctx.moveTo(-width / 2, 0);
                ctx.lineTo(-tipWidth / 2, -length);
                ctx.lineTo(tipWidth / 2, -length);
                ctx.lineTo(width / 2, 0);
                ctx.closePath();
                ctx.fill();

                // Draw facet lines
                ctx.strokeStyle = this.palette.light;
                ctx.lineWidth = 0.5;
                ctx.globalAlpha = 0.4 * shimmer;

                // Vertical facet lines
                for (let i = 1; i < facets; i++) {
                    const t = i / facets;
                    const x1 = -width / 2 + width * t;
                    const x2 = -tipWidth / 2 + tipWidth * t;
                    ctx.beginPath();
                    ctx.moveTo(x1, 0);
                    ctx.lineTo(x2, -length);
                    ctx.stroke();
                }

                // Horizontal bands
                const bands = 3;
                for (let i = 1; i < bands; i++) {
                    const t = i / bands;
                    const y = -length * t;
                    const w = width - (width - tipWidth) * t;
                    ctx.beginPath();
                    ctx.moveTo(-w / 2, y);
                    ctx.lineTo(w / 2, y);
                    ctx.stroke();
                }

                // Crystal tip highlight
                ctx.fillStyle = this.palette.glow;
                ctx.globalAlpha = 0.6 * shimmer;
                ctx.beginPath();
                ctx.moveTo(-tipWidth / 3, -length * 0.85);
                ctx.lineTo(0, -length);
                ctx.lineTo(tipWidth / 3, -length * 0.85);
                ctx.closePath();
                ctx.fill();

                // Edge highlight
                ctx.strokeStyle = this.palette.glow;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.5 * shimmer;
                ctx.beginPath();
                ctx.moveTo(-width / 2, 0);
                ctx.lineTo(-tipWidth / 2, -length);
                ctx.stroke();

                ctx.globalAlpha = 1;
            }
        }

        class Sparkle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = 2 + Math.random() * 4;
                this.life = 1;
                this.decay = 0.02 + Math.random() * 0.02;
            }

            update() {
                this.life -= this.decay;
                return this.life > 0;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.globalAlpha = this.life;

                // Draw 4-point star sparkle
                ctx.fillStyle = this.color;
                ctx.beginPath();
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2 + time * 2;
                    const outerDist = this.size * this.life;
                    const innerDist = outerDist * 0.3;

                    if (i === 0) {
                        ctx.moveTo(Math.cos(angle) * outerDist, Math.sin(angle) * outerDist);
                    } else {
                        ctx.lineTo(Math.cos(angle) * outerDist, Math.sin(angle) * outerDist);
                    }

                    const innerAngle = angle + Math.PI / 4;
                    ctx.lineTo(Math.cos(innerAngle) * innerDist, Math.sin(innerAngle) * innerDist);
                }
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }
        }

        function init() {
            crystals = [];
            sparkles = [];

            // Create crystal clusters
            const clusterCount = 4 + Math.floor(Math.random() * 3);

            for (let i = 0; i < clusterCount; i++) {
                const clusterX = 100 + (canvas.width - 200) * (i / (clusterCount - 1)) + (Math.random() - 0.5) * 80;
                const clusterY = canvas.height - 50 - Math.random() * 30;

                // Main crystal
                const mainCrystal = new Crystal(clusterX, clusterY);
                crystals.push(mainCrystal);

                // Smaller surrounding crystals
                const smallCount = 2 + Math.floor(Math.random() * 3);
                for (let j = 0; j < smallCount; j++) {
                    const offsetX = (Math.random() - 0.5) * 60;
                    const offsetY = Math.random() * 20;
                    const smallCrystal = new Crystal(clusterX + offsetX, clusterY + offsetY, true);
                    smallCrystal.growthSpeed *= 0.7;
                    crystals.push(smallCrystal);
                }
            }
        }

        init();
        let resetTimer = 0;

        // ============================================
        // ANIMATION LOOP
        // ============================================

        function animate() {
            // Dark gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a0a12');
            gradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Rocky base
            ctx.fillStyle = '#2d2d3a';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            for (let x = 0; x <= canvas.width; x += 30) {
                const y = canvas.height - 40 - Math.sin(x * 0.02) * 10 - Math.random() * 5;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.fill();

            // Update and draw crystals
            let allGrown = true;
            crystals.forEach(crystal => {
                crystal.update();
                crystal.draw();
                if (crystal.growth < 1) allGrown = false;
            });

            // Update and draw sparkles
            sparkles = sparkles.filter(sparkle => {
                sparkle.draw();
                return sparkle.update();
            });

            // Reset after all grown
            if (allGrown) {
                resetTimer++;
                if (resetTimer > 500) {
                    resetTimer = 0;
                    init();
                }
            }

            time += 0.02;
            requestAnimationFrame(animate);
        }

        animate();

        // ============================================
        // RESPONSIVE RESIZE
        // ============================================
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            init();
        });
    </script>
</body>
</html>