<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="@wisdomabioye">
    <meta name="description" content="Art Series #024 - forest-breeze">
    <meta name="created" content="2025-11-17">
    <title>forest-breeze | Art Series #024</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        /**
         * Art Series #024
         * Title: forest-breeze
         * Author: @wisdomabioye
         * Created: 2025-11-17
         * Description: Forest trees swaying in the breeze with leaves, grass, and atmospheric wind particles
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ============================================
        // MAIN ANIMATION CODE
        // ============================================

        const trees = [];
        const leaves = [];
        const grassBlades = [];
        const windParticles = [];
        let time = 0;
        let windStrength = 0;
        let windDirection = 0;

        class Tree {
            constructor(x, depth) {
                this.x = x;
                this.depth = depth; // 0-1, closer trees = 1
                this.groundY = canvas.height * 0.75;

                // Size based on depth
                this.scale = 0.5 + depth * 0.8;
                this.height = (100 + Math.random() * 150) * this.scale;
                this.trunkWidth = (15 + Math.random() * 10) * this.scale;

                // Sway parameters
                this.swaySpeed = 0.02 + Math.random() * 0.01;
                this.swayAmount = 0.05 + Math.random() * 0.03;
                this.phase = Math.random() * Math.PI * 2;

                // Color variation
                this.trunkHue = 25 + Math.random() * 10;
                this.foliageHue = 100 + Math.random() * 40;

                // Foliage clusters
                this.foliageClusters = [];
                const numClusters = 3 + Math.floor(Math.random() * 4);
                for (let i = 0; i < numClusters; i++) {
                    this.foliageClusters.push({
                        offsetX: (Math.random() - 0.5) * this.trunkWidth * 2,
                        offsetY: -this.height * (0.4 + i * 0.15),
                        radius: (30 + Math.random() * 40) * this.scale
                    });
                }
            }

            getSway(time) {
                return Math.sin(time * this.swaySpeed + this.phase + windDirection) *
                       this.swayAmount * windStrength * this.height;
            }

            draw(time) {
                const sway = this.getSway(time);

                ctx.save();
                ctx.globalAlpha = 0.5 + this.depth * 0.5;

                // Draw trunk
                const trunkGradient = ctx.createLinearGradient(
                    this.x - this.trunkWidth / 2, this.groundY,
                    this.x + this.trunkWidth / 2, this.groundY
                );
                trunkGradient.addColorStop(0, `hsl(${this.trunkHue}, 40%, 25%)`);
                trunkGradient.addColorStop(0.5, `hsl(${this.trunkHue}, 35%, 30%)`);
                trunkGradient.addColorStop(1, `hsl(${this.trunkHue}, 40%, 20%)`);

                ctx.fillStyle = trunkGradient;
                ctx.beginPath();
                ctx.moveTo(this.x - this.trunkWidth / 2, this.groundY);
                ctx.lineTo(this.x - this.trunkWidth / 3 + sway, this.groundY - this.height);
                ctx.lineTo(this.x + this.trunkWidth / 3 + sway, this.groundY - this.height);
                ctx.lineTo(this.x + this.trunkWidth / 2, this.groundY);
                ctx.closePath();
                ctx.fill();

                // Draw foliage clusters
                for (let cluster of this.foliageClusters) {
                    const clusterX = this.x + cluster.offsetX + sway * (1 + cluster.offsetY / this.height);
                    const clusterY = this.groundY + cluster.offsetY;

                    const foliageGradient = ctx.createRadialGradient(
                        clusterX - cluster.radius * 0.3,
                        clusterY - cluster.radius * 0.3,
                        0,
                        clusterX,
                        clusterY,
                        cluster.radius
                    );
                    foliageGradient.addColorStop(0, `hsla(${this.foliageHue}, 60%, 45%, 0.8)`);
                    foliageGradient.addColorStop(0.5, `hsla(${this.foliageHue}, 55%, 35%, 0.7)`);
                    foliageGradient.addColorStop(1, `hsla(${this.foliageHue - 10}, 50%, 25%, 0.5)`);

                    ctx.fillStyle = foliageGradient;
                    ctx.beginPath();
                    ctx.arc(clusterX, clusterY, cluster.radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }

            createLeaf() {
                if (Math.random() < 0.005 * windStrength) {
                    const cluster = this.foliageClusters[Math.floor(Math.random() * this.foliageClusters.length)];
                    const sway = this.getSway(time);
                    leaves.push(new Leaf(
                        this.x + cluster.offsetX + sway,
                        this.groundY + cluster.offsetY,
                        this.foliageHue,
                        this.scale
                    ));
                }
            }
        }

        class Leaf {
            constructor(x, y, hue, scale) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.3) * 2 + windStrength * 0.5;
                this.vy = Math.random() * 0.5;
                this.size = (3 + Math.random() * 5) * scale;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                this.hue = hue + (Math.random() - 0.5) * 20;
                this.life = 1;
                this.decay = 0.995;
            }

            update() {
                this.x += this.vx + windStrength * 0.3;
                this.y += this.vy;
                this.vy += 0.02; // Gravity
                this.rotation += this.rotationSpeed;
                this.life *= this.decay;
                this.vx *= 0.99;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                ctx.fillStyle = `hsl(${this.hue}, 60%, 40%)`;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            isDead() {
                return this.life < 0.01 || this.y > canvas.height;
            }
        }

        class GrassBlade {
            constructor(x, depth) {
                this.x = x;
                this.depth = depth;
                this.baseY = canvas.height * 0.75;
                this.height = (20 + Math.random() * 30) * (0.6 + depth * 0.4);
                this.width = 2;
                this.swaySpeed = 0.03 + Math.random() * 0.02;
                this.phase = Math.random() * Math.PI * 2;
                this.swayAmount = 0.3 + Math.random() * 0.2;
            }

            draw(time) {
                const sway = Math.sin(time * this.swaySpeed + this.phase) *
                            this.swayAmount * windStrength * this.height;

                ctx.save();
                ctx.globalAlpha = 0.4 + this.depth * 0.3;

                const gradient = ctx.createLinearGradient(
                    this.x, this.baseY,
                    this.x + sway, this.baseY - this.height
                );
                gradient.addColorStop(0, `hsl(100, 50%, 30%)`);
                gradient.addColorStop(1, `hsl(110, 55%, 45%)`);

                ctx.strokeStyle = gradient;
                ctx.lineWidth = this.width;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(this.x, this.baseY);
                ctx.quadraticCurveTo(
                    this.x + sway * 0.5,
                    this.baseY - this.height * 0.5,
                    this.x + sway,
                    this.baseY - this.height
                );
                ctx.stroke();

                ctx.restore();
            }
        }

        class WindParticle {
            constructor() {
                this.x = -50;
                this.y = Math.random() * canvas.height * 0.7;
                this.vx = 2 + Math.random() * 3;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.size = Math.random() * 2 + 1;
                this.opacity = Math.random() * 0.3;
            }

            update() {
                this.x += this.vx * windStrength;
                this.y += this.vy;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = 'rgba(200, 220, 240, 0.5)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.x > canvas.width + 50;
            }
        }

        // Initialize trees (back to front)
        for (let i = 0; i < 30; i++) {
            const depth = Math.random();
            const x = Math.random() * canvas.width;
            trees.push(new Tree(x, depth));
        }

        // Sort trees by depth
        trees.sort((a, b) => a.depth - b.depth);

        // Initialize grass
        for (let i = 0; i < 200; i++) {
            const depth = Math.random();
            const x = Math.random() * canvas.width;
            grassBlades.push(new GrassBlade(x, depth));
        }

        grassBlades.sort((a, b) => a.depth - b.depth);

        // ============================================
        // ANIMATION LOOP
        // ============================================

        function animate() {
            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#87CEEB');
            skyGradient.addColorStop(0.6, '#B0E2FF');
            skyGradient.addColorStop(1, '#90EE90');

            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            time += 0.5;

            // Animate wind strength
            windStrength = 0.5 + Math.sin(time * 0.01) * 0.3 + Math.sin(time * 0.03) * 0.2;
            windDirection = Math.sin(time * 0.005) * 0.5;

            // Create wind particles
            if (Math.random() < 0.1) {
                windParticles.push(new WindParticle());
            }

            // Update and draw wind particles
            for (let i = windParticles.length - 1; i >= 0; i--) {
                windParticles[i].update();
                windParticles[i].draw();

                if (windParticles[i].isDead()) {
                    windParticles.splice(i, 1);
                }
            }

            // Draw ground
            const groundGradient = ctx.createLinearGradient(0, canvas.height * 0.75, 0, canvas.height);
            groundGradient.addColorStop(0, '#5a8a3a');
            groundGradient.addColorStop(1, '#4a7a2a');

            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, canvas.height * 0.75, canvas.width, canvas.height * 0.25);

            // Draw grass
            for (let blade of grassBlades) {
                blade.draw(time);
            }

            // Draw trees and create leaves
            for (let tree of trees) {
                tree.draw(time);
                tree.createLeaf();
            }

            // Update and draw leaves
            for (let i = leaves.length - 1; i >= 0; i--) {
                leaves[i].update();
                leaves[i].draw();

                if (leaves[i].isDead()) {
                    leaves.splice(i, 1);
                }
            }

            requestAnimationFrame(animate);
        }

        animate();

        // ============================================
        // RESPONSIVE RESIZE
        // ============================================
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>