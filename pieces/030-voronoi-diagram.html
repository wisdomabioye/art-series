<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="@wisdomabioye">
    <meta name="description" content="Art Series #030 - voronoi-diagram">
    <meta name="created" content="2025-11-23">
    <title>voronoi-diagram | Art Series #030</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        /**
         * Art Series #030
         * Title: voronoi-diagram
         * Author: @wisdomabioye
         * Created: 2025-11-23
         * Description: Animated Voronoi diagram with moving seed points and dynamic color gradients
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ============================================
        // MAIN ANIMATION CODE
        // ============================================

        // Point class for seed points
        class Point {
            constructor(x, y, vx, vy, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Bounce off edges
                if (this.x < 0 || this.x > canvas.width) {
                    this.vx *= -1;
                    this.x = Math.max(0, Math.min(canvas.width, this.x));
                }
                if (this.y < 0 || this.y > canvas.height) {
                    this.vy *= -1;
                    this.y = Math.max(0, Math.min(canvas.height, this.y));
                }
            }
        }

        // Color palette
        const colorPalette = [
            '#FF006E', // Hot pink
            '#8338EC', // Purple
            '#3A86FF', // Blue
            '#06FFA5', // Cyan
            '#FFBE0B', // Yellow
            '#FB5607', // Orange
            '#FF1654', // Red
            '#4ECDC4', // Teal
            '#95E1D3', // Mint
            '#F38181'  // Coral
        ];

        // Create seed points
        const numPoints = 25;
        const points = [];
        let time = 0;

        function initPoints() {
            points.length = 0;
            for (let i = 0; i < numPoints; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const angle = Math.random() * Math.PI * 2;
                const speed = 0.3 + Math.random() * 0.7;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                const color = colorPalette[i % colorPalette.length];

                points.push(new Point(x, y, vx, vy, color));
            }
        }

        // Calculate distance between two points
        function distance(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Find closest point for a given pixel
        function findClosestPoint(x, y) {
            let minDist = Infinity;
            let closestPoint = null;
            let secondClosestDist = Infinity;

            for (const point of points) {
                const dist = distance(x, y, point.x, point.y);
                if (dist < minDist) {
                    secondClosestDist = minDist;
                    minDist = dist;
                    closestPoint = point;
                } else if (dist < secondClosestDist) {
                    secondClosestDist = dist;
                }
            }

            return { point: closestPoint, dist: minDist, edgeDist: secondClosestDist - minDist };
        }

        // Convert hex color to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // Draw Voronoi diagram using pixel-by-pixel approach (optimized with larger pixels)
        function drawVoronoi() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const pixelSize = 4; // Draw larger pixels for performance

            for (let y = 0; y < canvas.height; y += pixelSize) {
                for (let x = 0; x < canvas.width; x += pixelSize) {
                    const { point, dist, edgeDist } = findClosestPoint(x, y);

                    if (point) {
                        const rgb = hexToRgb(point.color);

                        // Create edge highlighting
                        const edgeThreshold = 2;
                        let brightness = 1;

                        if (edgeDist < edgeThreshold) {
                            // Near an edge - make it darker
                            brightness = 0.3 + (edgeDist / edgeThreshold) * 0.7;
                        }

                        // Add subtle distance-based gradient
                        const maxDist = 200;
                        const distFactor = Math.min(dist / maxDist, 1);
                        brightness *= (1 - distFactor * 0.3);

                        // Add time-based pulsing effect
                        const pulse = Math.sin(time * 2 + dist * 0.01) * 0.1 + 0.9;
                        brightness *= pulse;

                        const r = Math.floor(rgb.r * brightness);
                        const g = Math.floor(rgb.g * brightness);
                        const b = Math.floor(rgb.b * brightness);

                        // Fill the larger pixel area
                        for (let py = 0; py < pixelSize && y + py < canvas.height; py++) {
                            for (let px = 0; px < pixelSize && x + px < canvas.width; px++) {
                                const index = ((y + py) * canvas.width + (x + px)) * 4;
                                imageData.data[index] = r;
                                imageData.data[index + 1] = g;
                                imageData.data[index + 2] = b;
                                imageData.data[index + 3] = 255;
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Draw seed points
        function drawPoints() {
            points.forEach(point => {
                // Draw glow
                const gradient = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, 15);
                gradient.addColorStop(0, point.color);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(point.x, point.y, 15, 0, Math.PI * 2);
                ctx.fill();

                // Draw center point
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Initialize
        initPoints();



        // ============================================
        // ANIMATION LOOP
        // ============================================
        
        function animate() {
            // Update all points
            points.forEach(point => point.update());

            // Draw Voronoi diagram
            drawVoronoi();

            // Draw seed points on top
            drawPoints();

            // Update time
            time += 0.02;

            requestAnimationFrame(animate);
        }

        animate();

        // ============================================
        // RESPONSIVE RESIZE
        // ============================================
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initPoints(); // Reinitialize points on resize
        });
    </script>
</body>
</html>