<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="@wisdomabioye">
    <meta name="description" content="Art Series #033 - mandala-generator">
    <meta name="created" content="2025-11-26">
    <title>mandala-generator | Art Series #033</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        /**
         * Art Series #033
         * Title: mandala-generator
         * Author: @wisdomabioye
         * Created: 2025-11-26
         * Description: Animated mandala with radial symmetry, rotating geometric patterns, and gradient colors
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ============================================
        // MAIN ANIMATION CODE
        // ============================================

        let time = 0;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Color palette
        const colors = [
            '#FF006E', '#8338EC', '#3A86FF', '#06FFA5', '#FFBE0B',
            '#FB5607', '#FF1654', '#4ECDC4', '#95E1D3', '#F38181'
        ];

        // Draw with radial symmetry
        function drawRadial(fn, segments = 12, rotation = 0) {
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(rotation);

            for (let i = 0; i < segments; i++) {
                ctx.save();
                ctx.rotate((Math.PI * 2 / segments) * i);
                fn();
                ctx.restore();
            }

            ctx.restore();
        }

        // Draw a petal shape
        function drawPetal(radius, width, color) {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;

            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(width, radius / 2, 0, radius);
            ctx.quadraticCurveTo(-width, radius / 2, 0, 0);
            ctx.closePath();

            ctx.globalAlpha = 0.3;
            ctx.fill();
            ctx.globalAlpha = 0.8;
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        // Draw a lotus petal
        function drawLotusPetal(radius, width, color) {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 1.5;

            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.bezierCurveTo(
                width / 2, radius * 0.3,
                width, radius * 0.7,
                0, radius
            );
            ctx.bezierCurveTo(
                -width, radius * 0.7,
                -width / 2, radius * 0.3,
                0, 0
            );
            ctx.closePath();

            ctx.globalAlpha = 0.4;
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.stroke();
        }

        // Draw a circle with decorations
        function drawDecorativeCircle(radius, color, thickness = 2) {
            ctx.strokeStyle = color;
            ctx.lineWidth = thickness;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Draw geometric pattern
        function drawGeometricPattern(radius, sides, color, filled = false) {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;

            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (Math.PI * 2 / sides) * i;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();

            if (filled) {
                ctx.globalAlpha = 0.2;
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            ctx.stroke();
        }

        // Draw dots around a circle
        function drawDotRing(radius, count, dotSize, color) {
            ctx.fillStyle = color;

            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                ctx.beginPath();
                ctx.arc(x, y, dotSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw wavy circle
        function drawWavyCircle(radius, waves, amplitude, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            ctx.beginPath();
            for (let i = 0; i <= 360; i++) {
                const angle = (i * Math.PI) / 180;
                const wave = Math.sin(angle * waves + time) * amplitude;
                const r = radius + wave;
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.stroke();
        }

        // Draw star burst
        function drawStarBurst(innerRadius, outerRadius, points, color) {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;

            ctx.beginPath();
            for (let i = 0; i < points * 2; i++) {
                const angle = (Math.PI * 2 / (points * 2)) * i;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();

            ctx.globalAlpha = 0.2;
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.stroke();
        }

        // Draw connecting lines between points
        function drawSpokes(radius, count, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;

            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(x, y);
                ctx.stroke();
            }

            ctx.globalAlpha = 1;
        }



        // ============================================
        // ANIMATION LOOP
        // ============================================
        
        function animate() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate max radius based on screen size
            const maxRadius = Math.min(canvas.width, canvas.height) * 0.45;

            // Draw mandala layers from outside to inside
            ctx.save();
            ctx.translate(centerX, centerY);

            // Layer 1: Outer spokes
            drawSpokes(maxRadius, 24, colors[0]);

            // Layer 2: Outer decorative circle
            drawDecorativeCircle(maxRadius * 0.95, colors[1], 3);

            // Layer 3: Outer petals (rotating slowly)
            ctx.restore();
            drawRadial(() => {
                drawLotusPetal(maxRadius * 0.85, maxRadius * 0.15, colors[2]);
            }, 16, time * 0.2);

            // Layer 4: Star burst
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(time * 0.3);
            drawStarBurst(maxRadius * 0.5, maxRadius * 0.7, 12, colors[3]);
            ctx.restore();

            // Layer 5: Wavy circle (animated)
            ctx.save();
            ctx.translate(centerX, centerY);
            drawWavyCircle(maxRadius * 0.6, 8, 10, colors[4]);
            ctx.restore();

            // Layer 6: Middle petals (counter-rotating)
            drawRadial(() => {
                drawPetal(maxRadius * 0.5, maxRadius * 0.1, colors[5]);
            }, 12, -time * 0.25);

            // Layer 7: Geometric polygon
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(time * 0.15);
            drawGeometricPattern(maxRadius * 0.45, 8, colors[6], true);
            ctx.restore();

            // Layer 8: Dot ring
            ctx.save();
            ctx.translate(centerX, centerY);
            drawDotRing(maxRadius * 0.4, 24, 4, colors[7]);
            ctx.restore();

            // Layer 9: Inner decorative circles
            ctx.save();
            ctx.translate(centerX, centerY);
            drawDecorativeCircle(maxRadius * 0.35, colors[8], 2);
            drawDecorativeCircle(maxRadius * 0.3, colors[9], 2);
            ctx.restore();

            // Layer 10: Inner rotating petals
            drawRadial(() => {
                drawLotusPetal(maxRadius * 0.25, maxRadius * 0.08, colors[0]);
            }, 8, time * 0.4);

            // Layer 11: Center star
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(-time * 0.5);
            drawStarBurst(maxRadius * 0.05, maxRadius * 0.15, 6, colors[1]);
            ctx.restore();

            // Layer 12: Center circle
            ctx.save();
            ctx.translate(centerX, centerY);
            drawDecorativeCircle(maxRadius * 0.08, colors[2], 3);
            ctx.restore();

            // Center dot
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx.fill();

            // Update time
            time += 0.01;

            requestAnimationFrame(animate);
        }

        animate();

        // ============================================
        // RESPONSIVE RESIZE
        // ============================================
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>