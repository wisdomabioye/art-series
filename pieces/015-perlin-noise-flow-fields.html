<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="@wisdomabioye">
    <meta name="description" content="Art Series #015 - perlin-noise-flow-fields">
    <meta name="created" content="2025-11-08">
    <title>perlin-noise-flow-fields | Art Series #015</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        /**
         * Art Series #015
         * Title: perlin-noise-flow-fields
         * Author: @wisdomabioye
         * Created: 2025-11-08
         * Description: Particles following Perlin noise-based vector flow fields
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ============================================
        // MAIN ANIMATION CODE
        // ============================================

        // Simplified Perlin Noise implementation
        class PerlinNoise {
            constructor() {
                this.gradients = {};
                this.memory = {};
            }

            rand_vect() {
                let theta = Math.random() * 2 * Math.PI;
                return { x: Math.cos(theta), y: Math.sin(theta) };
            }

            dot_prod_grid(x, y, vx, vy) {
                let g_vect;
                let d_vect = { x: x - vx, y: y - vy };
                let grid_key = `${vx},${vy}`;

                if (this.gradients[grid_key]) {
                    g_vect = this.gradients[grid_key];
                } else {
                    g_vect = this.rand_vect();
                    this.gradients[grid_key] = g_vect;
                }

                return d_vect.x * g_vect.x + d_vect.y * g_vect.y;
            }

            smootherstep(x) {
                return 6 * x ** 5 - 15 * x ** 4 + 10 * x ** 3;
            }

            interp(x, a, b) {
                return a + this.smootherstep(x) * (b - a);
            }

            get(x, y) {
                let mem_key = `${x},${y}`;
                if (this.memory[mem_key]) {
                    return this.memory[mem_key];
                }

                let xf = Math.floor(x);
                let yf = Math.floor(y);

                let tl = this.dot_prod_grid(x, y, xf, yf);
                let tr = this.dot_prod_grid(x, y, xf + 1, yf);
                let bl = this.dot_prod_grid(x, y, xf, yf + 1);
                let br = this.dot_prod_grid(x, y, xf + 1, yf + 1);

                let xt = this.interp(x - xf, tl, tr);
                let xb = this.interp(x - xf, bl, br);
                let v = this.interp(y - yf, xt, xb);

                this.memory[mem_key] = v;
                return v;
            }
        }

        const noise = new PerlinNoise();
        const flowfield = [];
        const particles = [];
        const resolution = 20;
        const cols = Math.floor(canvas.width / resolution);
        const rows = Math.floor(canvas.height / resolution);
        let zoff = 0;

        // Particle class
        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = 0;
                this.vy = 0;
                this.maxSpeed = 2;
                this.prevX = this.x;
                this.prevY = this.y;

                // Color based on position
                this.hue = (this.x / canvas.width) * 360;
            }

            follow(flowfield) {
                let x = Math.floor(this.x / resolution);
                let y = Math.floor(this.y / resolution);
                let index = x + y * cols;

                if (flowfield[index]) {
                    let force = flowfield[index];
                    this.vx += force.x * 0.1;
                    this.vy += force.y * 0.1;
                }
            }

            update() {
                // Limit velocity
                let speed = Math.sqrt(this.vx ** 2 + this.vy ** 2);
                if (speed > this.maxSpeed) {
                    this.vx = (this.vx / speed) * this.maxSpeed;
                    this.vy = (this.vy / speed) * this.maxSpeed;
                }

                this.prevX = this.x;
                this.prevY = this.y;

                this.x += this.vx;
                this.y += this.vy;

                // Wrap edges
                if (this.x > canvas.width) {
                    this.x = 0;
                    this.prevX = this.x;
                }
                if (this.x < 0) {
                    this.x = canvas.width;
                    this.prevX = this.x;
                }
                if (this.y > canvas.height) {
                    this.y = 0;
                    this.prevY = this.y;
                }
                if (this.y < 0) {
                    this.y = canvas.height;
                    this.prevY = this.y;
                }
            }

            draw() {
                ctx.save();

                // Draw line from previous position
                ctx.strokeStyle = `hsla(${this.hue}, 70%, 60%, 0.5)`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(this.prevX, this.prevY);
                ctx.lineTo(this.x, this.y);
                ctx.stroke();

                // Draw particle
                ctx.fillStyle = `hsl(${this.hue}, 80%, 70%)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 1.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // Initialize particles
        for (let i = 0; i < 1000; i++) {
            particles.push(new Particle());
        }

        // Generate flow field
        function generateFlowField() {
            let yoff = 0;
            for (let y = 0; y < rows; y++) {
                let xoff = 0;
                for (let x = 0; x < cols; x++) {
                    let index = x + y * cols;

                    let angle = noise.get(xoff, yoff + zoff) * Math.PI * 4;
                    let v = {
                        x: Math.cos(angle),
                        y: Math.sin(angle)
                    };

                    flowfield[index] = v;
                    xoff += 0.1;
                }
                yoff += 0.1;
            }
            zoff += 0.005;
        }



        // ============================================
        // ANIMATION LOOP
        // ============================================
        
        function animate() {
            // Create fade trail effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update flow field
            generateFlowField();

            // Update and draw particles
            for (let particle of particles) {
                particle.follow(flowfield);
                particle.update();
                particle.draw();
            }

            requestAnimationFrame(animate);
        }

        animate();

        // ============================================
        // RESPONSIVE RESIZE
        // ============================================
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>