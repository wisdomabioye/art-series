<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="@wisdomabioye">
    <meta name="description" content="Art Series #039 - kaleidoscope-effects">
    <meta name="created" content="2025-12-02">
    <title>kaleidoscope-effects | Art Series #039</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        /**
         * Art Series #039
         * Title: kaleidoscope-effects
         * Author: @wisdomabioye
         * Created: 2025-12-02
         * Description: Animated kaleidoscope with radial symmetry, flowing particles, and rainbow colors
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ============================================
        // MAIN ANIMATION CODE
        // ============================================

        let time = 0;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const segments = 12; // Number of kaleidoscope segments

        // Particle class for kaleidoscope
        class KaleidoParticle {
            constructor() {
                this.reset();
            }

            reset() {
                this.angle = Math.random() * Math.PI * 2;
                this.radius = Math.random() * 200;
                this.speed = 0.5 + Math.random() * 2;
                this.size = 2 + Math.random() * 6;
                this.hue = Math.random() * 360;
                this.alpha = 0.5 + Math.random() * 0.5;
                this.rotationSpeed = (Math.random() - 0.5) * 0.05;
            }

            update() {
                this.radius += this.speed;
                this.angle += this.rotationSpeed;

                // Reset if too far
                if (this.radius > 400) {
                    this.reset();
                }
            }

            draw(ctx) {
                const x = Math.cos(this.angle) * this.radius;
                const y = Math.sin(this.angle) * this.radius;

                ctx.fillStyle = `hsla(${this.hue}, 80%, 60%, ${this.alpha})`;
                ctx.beginPath();
                ctx.arc(x, y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Shape class for more complex kaleidoscope patterns
        class KaleidoShape {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = (Math.random() - 0.5) * 100;
                this.y = (Math.random() - 0.5) * 100;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.size = 10 + Math.random() * 30;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1;
                this.hue = Math.random() * 360;
                this.shape = Math.floor(Math.random() * 3); // 0: circle, 1: square, 2: triangle
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rotationSpeed;

                // Bounce within bounds
                const maxDist = 300;
                const dist = Math.sqrt(this.x * this.x + this.y * this.y);
                if (dist > maxDist) {
                    const angle = Math.atan2(this.y, this.x);
                    this.vx = -Math.cos(angle) * Math.abs(this.vx);
                    this.vy = -Math.sin(angle) * Math.abs(this.vy);
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                const color = `hsla(${this.hue}, 85%, 65%, 0.7)`;
                ctx.fillStyle = color;
                ctx.strokeStyle = `hsla(${this.hue}, 85%, 75%, 0.9)`;
                ctx.lineWidth = 2;

                switch (this.shape) {
                    case 0: // Circle
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        break;

                    case 1: // Square
                        ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                        ctx.strokeRect(-this.size / 2, -this.size / 2, this.size, this.size);
                        break;

                    case 2: // Triangle
                        ctx.beginPath();
                        ctx.moveTo(0, -this.size / 2);
                        ctx.lineTo(this.size / 2, this.size / 2);
                        ctx.lineTo(-this.size / 2, this.size / 2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                }

                ctx.restore();
            }
        }

        // Create particles and shapes
        const particles = [];
        const shapes = [];

        for (let i = 0; i < 50; i++) {
            particles.push(new KaleidoParticle());
        }

        for (let i = 0; i < 15; i++) {
            shapes.push(new KaleidoShape());
        }

        // Draw with kaleidoscope symmetry
        function drawKaleidoscope(drawFunc) {
            ctx.save();
            ctx.translate(centerX, centerY);

            for (let i = 0; i < segments; i++) {
                ctx.save();

                // Rotate to segment position
                ctx.rotate((Math.PI * 2 / segments) * i);

                // Draw the content
                drawFunc();

                // Mirror the content for kaleidoscope effect
                ctx.save();
                ctx.scale(-1, 1);
                drawFunc();
                ctx.restore();

                ctx.restore();
            }

            ctx.restore();
        }

        // Draw segment dividers
        function drawDividers() {
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;

            for (let i = 0; i < segments; i++) {
                const angle = (Math.PI * 2 / segments) * i;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * 500, Math.sin(angle) * 500);
                ctx.stroke();
            }

            ctx.restore();
        }



        // ============================================
        // ANIMATION LOOP
        // ============================================
        
        function animate() {
            // Clear canvas with trail effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update all particles
            particles.forEach(particle => particle.update());
            shapes.forEach(shape => shape.update());

            // Draw dividers
            drawDividers();

            // Draw particles with kaleidoscope symmetry
            drawKaleidoscope(() => {
                particles.forEach(particle => particle.draw(ctx));
            });

            // Draw shapes with kaleidoscope symmetry
            drawKaleidoscope(() => {
                shapes.forEach(shape => shape.draw(ctx));
            });

            // Draw center glow
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 50);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 50, 0, Math.PI * 2);
            ctx.fill();

            // Update time
            time += 0.01;

            requestAnimationFrame(animate);
        }

        animate();

        // ============================================
        // RESPONSIVE RESIZE
        // ============================================
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>