<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="@wisdomabioye">
    <meta name="description" content="Art Series #009 - fireflies-at-night">
    <meta name="created" content="2025-11-02">
    <title>fireflies-at-night | Art Series #009</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at bottom, #0d1b2a 0%, #020408 70%, #000000 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        /**
         * Art Series #009
         * Title: fireflies-at-night
         * Author: @wisdomabioye
         * Created: 2025-11-02
         * Description: Glowing fireflies with pulsing lights floating through a dark night scene
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ============================================
        // MAIN ANIMATION CODE
        // ============================================

        class Firefly {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;

                // Glow properties
                this.glowPhase = Math.random() * Math.PI * 2;
                this.glowSpeed = 0.02 + Math.random() * 0.03;
                this.maxGlow = 15 + Math.random() * 10;
                this.minGlow = 3;

                // Size and color
                this.size = 2 + Math.random() * 1;
                this.hue = 50 + Math.random() * 15; // Yellow-green range

                // Trail
                this.trail = [];
                this.maxTrailLength = 15;

                // Wandering behavior
                this.targetX = this.x;
                this.targetY = this.y;
                this.targetChangeCounter = 0;
                this.targetChangeInterval = Math.random() * 100 + 50;
            }

            updateTarget() {
                this.targetChangeCounter++;
                if (this.targetChangeCounter > this.targetChangeInterval) {
                    this.targetX = Math.random() * canvas.width;
                    this.targetY = Math.random() * canvas.height;
                    this.targetChangeCounter = 0;
                    this.targetChangeInterval = Math.random() * 100 + 50;
                }
            }

            update() {
                // Update glow
                this.glowPhase += this.glowSpeed;

                // Store trail
                this.trail.push({ x: this.x, y: this.y, glow: this.getCurrentGlow() });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }

                // Update target
                this.updateTarget();

                // Move towards target with smooth interpolation
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                this.vx += dx * 0.0001;
                this.vy += dy * 0.0001;

                // Add some randomness
                this.vx += (Math.random() - 0.5) * 0.05;
                this.vy += (Math.random() - 0.5) * 0.05;

                // Damping
                this.vx *= 0.98;
                this.vy *= 0.98;

                // Limit speed
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 1) {
                    this.vx = (this.vx / speed) * 1;
                    this.vy = (this.vy / speed) * 1;
                }

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Wrap around edges
                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }

            getCurrentGlow() {
                // Pulsing glow using sine wave
                const pulse = Math.sin(this.glowPhase);
                return this.minGlow + (pulse * 0.5 + 0.5) * (this.maxGlow - this.minGlow);
            }

            draw() {
                ctx.save();

                // Draw trail
                for (let i = 0; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    const alpha = (i / this.trail.length) * 0.3;
                    const trailGlow = point.glow * (i / this.trail.length);

                    ctx.globalAlpha = alpha;
                    const gradient = ctx.createRadialGradient(
                        point.x, point.y, 0,
                        point.x, point.y, trailGlow
                    );
                    gradient.addColorStop(0, `hsla(${this.hue}, 100%, 70%, ${alpha})`);
                    gradient.addColorStop(0.5, `hsla(${this.hue}, 100%, 50%, ${alpha * 0.5})`);
                    gradient.addColorStop(1, `hsla(${this.hue}, 100%, 30%, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, trailGlow, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw main glow
                const currentGlow = this.getCurrentGlow();
                ctx.globalAlpha = 1;

                // Outer glow
                const outerGradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, currentGlow
                );
                outerGradient.addColorStop(0, `hsla(${this.hue}, 100%, 80%, 0.8)`);
                outerGradient.addColorStop(0.3, `hsla(${this.hue}, 100%, 60%, 0.5)`);
                outerGradient.addColorStop(0.6, `hsla(${this.hue}, 100%, 40%, 0.2)`);
                outerGradient.addColorStop(1, `hsla(${this.hue}, 100%, 20%, 0)`);

                ctx.fillStyle = outerGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentGlow, 0, Math.PI * 2);
                ctx.fill();

                // Inner bright core
                const coreGradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size * 2
                );
                coreGradient.addColorStop(0, `hsla(${this.hue}, 100%, 90%, 1)`);
                coreGradient.addColorStop(0.5, `hsla(${this.hue}, 100%, 70%, 0.8)`);
                coreGradient.addColorStop(1, `hsla(${this.hue}, 100%, 50%, 0)`);

                ctx.fillStyle = coreGradient;
                ctx.shadowBlur = currentGlow;
                ctx.shadowColor = `hsla(${this.hue}, 100%, 60%, 1)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // Create fireflies
        const fireflies = [];
        const numFireflies = 50;

        for (let i = 0; i < numFireflies; i++) {
            fireflies.push(new Firefly());
        }

        // Draw stars
        function drawStars() {
            ctx.fillStyle = 'white';
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height * 0.5;
                const size = Math.random() * 1;
                const alpha = Math.random() * 0.5 + 0.3;

                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        // Draw grass silhouette
        function drawGrass() {
            ctx.fillStyle = 'rgba(10, 20, 15, 0.8)';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);

            for (let x = 0; x <= canvas.width; x += 20) {
                const height = 50 + Math.random() * 100;
                ctx.lineTo(x, canvas.height - height);
            }

            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
        }



        // ============================================
        // ANIMATION LOOP
        // ============================================
        
        let starsDrawn = false;
        let grassDrawn = false;

        function animate() {
            // Clear with dark transparent layer for trails
            ctx.fillStyle = 'rgba(2, 4, 8, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars once
            if (!starsDrawn) {
                drawStars();
                starsDrawn = true;
            }

            // Update and draw fireflies
            for (let firefly of fireflies) {
                firefly.update();
                firefly.draw();
            }

            // Draw grass silhouette in front
            if (!grassDrawn) {
                drawGrass();
                grassDrawn = true;
            } else {
                ctx.save();
                ctx.globalAlpha = 0.8;
                drawGrass();
                ctx.restore();
            }

            requestAnimationFrame(animate);
        }

        animate();

        // ============================================
        // RESPONSIVE RESIZE
        // ============================================
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>