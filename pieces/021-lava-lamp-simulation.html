<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="@wisdomabioye">
    <meta name="description" content="Art Series #021 - lava-lamp-simulation">
    <meta name="created" content="2025-11-14">
    <title>lava-lamp-simulation | Art Series #021</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        /**
         * Art Series #021
         * Title: lava-lamp-simulation
         * Author: @wisdomabioye
         * Created: 2025-11-14
         * Description: Lava lamp with metaball blobs, rising/falling physics, and glowing colors
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ============================================
        // MAIN ANIMATION CODE
        // ============================================

        const blobs = [];
        const lampWidth = Math.min(400, canvas.width * 0.5);
        const lampHeight = Math.min(600, canvas.height * 0.8);
        const lampX = canvas.width / 2 - lampWidth / 2;
        const lampY = canvas.height / 2 - lampHeight / 2;

        class Blob {
            constructor() {
                this.x = lampX + lampWidth / 2 + (Math.random() - 0.5) * lampWidth * 0.4;
                this.y = lampY + lampHeight * (0.3 + Math.random() * 0.4);
                this.radius = 30 + Math.random() * 50;
                this.baseRadius = this.radius;

                // Physics
                this.vx = (Math.random() - 0.5) * 0.3;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.temperature = Math.random();
                this.mass = this.radius / 40;

                // Deformation
                this.deformX = 0;
                this.deformY = 0;
                this.targetDeformX = 0;
                this.targetDeformY = 0;
            }

            update() {
                // Temperature affects buoyancy
                const buoyancy = (this.temperature - 0.5) * 0.05;
                this.vy += buoyancy;

                // Gravity
                this.vy += 0.02 * (1 - this.temperature);

                // Apply velocity
                this.x += this.vx;
                this.y += this.vy;

                // Friction
                this.vx *= 0.99;
                this.vy *= 0.99;

                // Boundaries - bounce off lamp walls
                const margin = 20;
                if (this.x - this.radius < lampX + margin) {
                    this.x = lampX + margin + this.radius;
                    this.vx *= -0.5;
                }
                if (this.x + this.radius > lampX + lampWidth - margin) {
                    this.x = lampX + lampWidth - margin - this.radius;
                    this.vx *= -0.5;
                }

                // Top and bottom - reverse temperature and bounce
                if (this.y - this.radius < lampY + margin) {
                    this.y = lampY + margin + this.radius;
                    this.vy *= -0.3;
                    this.temperature = Math.max(0.1, this.temperature - 0.3);
                }
                if (this.y + this.radius > lampY + lampHeight - margin) {
                    this.y = lampY + lampHeight - margin - this.radius;
                    this.vy *= -0.3;
                    this.temperature = Math.min(0.9, this.temperature + 0.3);
                }

                // Slowly change temperature (simulating heating/cooling)
                if (this.y > lampY + lampHeight * 0.7) {
                    this.temperature = Math.min(1, this.temperature + 0.002);
                } else if (this.y < lampY + lampHeight * 0.3) {
                    this.temperature = Math.max(0, this.temperature - 0.002);
                }

                // Deformation based on velocity
                this.targetDeformX = this.vx * 3;
                this.targetDeformY = this.vy * 3;
                this.deformX += (this.targetDeformX - this.deformX) * 0.1;
                this.deformY += (this.targetDeformY - this.deformY) * 0.1;

                // Radius varies slightly with temperature
                this.radius = this.baseRadius * (0.9 + this.temperature * 0.2);
            }

            draw() {
                ctx.save();

                // Gradient based on temperature
                const gradient = ctx.createRadialGradient(
                    this.x - this.radius * 0.3,
                    this.y - this.radius * 0.3,
                    0,
                    this.x,
                    this.y,
                    this.radius
                );

                // Hot blobs are brighter
                const brightness = 40 + this.temperature * 30;
                gradient.addColorStop(0, `hsl(0, 90%, ${brightness + 20}%)`);
                gradient.addColorStop(0.5, `hsl(15, 85%, ${brightness}%)`);
                gradient.addColorStop(1, `hsl(25, 80%, ${brightness - 10}%)`);

                // Draw deformed blob
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(
                    this.x,
                    this.y,
                    this.radius + this.deformX,
                    this.radius + this.deformY,
                    0,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                ctx.restore();
            }

            // Check distance to another blob
            distanceTo(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        // Metaball rendering using image data
        function drawMetaballs() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            // Optimization: only process lamp area
            const startX = Math.max(0, Math.floor(lampX - 50));
            const endX = Math.min(canvas.width, Math.ceil(lampX + lampWidth + 50));
            const startY = Math.max(0, Math.floor(lampY - 50));
            const endY = Math.min(canvas.height, Math.ceil(lampY + lampHeight + 50));

            for (let y = startY; y < endY; y += 2) { // Step by 2 for performance
                for (let x = startX; x < endX; x += 2) {
                    let sum = 0;
                    let colorR = 0;
                    let colorG = 0;
                    let colorB = 0;

                    // Calculate metaball influence
                    for (let blob of blobs) {
                        const dx = x - blob.x;
                        const dy = y - blob.y;
                        const distSq = dx * dx + dy * dy;
                        const radiusSq = blob.radius * blob.radius;

                        if (distSq < radiusSq * 4) { // Only calculate if close enough
                            const influence = radiusSq / (distSq + 1);
                            sum += influence;

                            // Accumulate color based on temperature
                            const brightness = 40 + blob.temperature * 30;
                            colorR += influence * (255 * (brightness / 100));
                            colorG += influence * (100 * (brightness / 100));
                            colorB += influence * (50 * (brightness / 100));
                        }
                    }

                    // Threshold for metaball effect
                    if (sum > 1.2) {
                        const idx = (y * canvas.width + x) * 4;
                        const idx2 = (y * canvas.width + x + 1) * 4;
                        const idx3 = ((y + 1) * canvas.width + x) * 4;
                        const idx4 = ((y + 1) * canvas.width + x + 1) * 4;

                        const normalizedR = Math.min(255, colorR / sum * 1.5);
                        const normalizedG = Math.min(255, colorG / sum * 1.5);
                        const normalizedB = Math.min(255, colorB / sum * 1.5);

                        // Set 2x2 pixel block for smoother appearance
                        for (let i of [idx, idx2, idx3, idx4]) {
                            if (i < data.length) {
                                data[i] = normalizedR;
                                data[i + 1] = normalizedG;
                                data[i + 2] = normalizedB;
                                data[i + 3] = 255;
                            }
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // Initialize blobs
        for (let i = 0; i < 8; i++) {
            blobs.push(new Blob());
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================

        function animate() {
            // Dark background
            ctx.fillStyle = '#1a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw lamp container
            ctx.save();

            // Outer glass
            ctx.strokeStyle = 'rgba(100, 100, 120, 0.3)';
            ctx.lineWidth = 3;
            ctx.fillStyle = 'rgba(20, 15, 25, 0.6)';
            ctx.beginPath();
            ctx.roundRect(lampX, lampY, lampWidth, lampHeight, 20);
            ctx.fill();
            ctx.stroke();

            // Inner glow
            const lampGlow = ctx.createRadialGradient(
                lampX + lampWidth / 2,
                lampY + lampHeight,
                0,
                lampX + lampWidth / 2,
                lampY + lampHeight,
                lampWidth / 2
            );
            lampGlow.addColorStop(0, 'rgba(255, 100, 50, 0.1)');
            lampGlow.addColorStop(1, 'rgba(255, 100, 50, 0)');
            ctx.fillStyle = lampGlow;
            ctx.fillRect(lampX, lampY, lampWidth, lampHeight);

            ctx.restore();

            // Update blobs
            for (let blob of blobs) {
                blob.update();
            }

            // Draw metaballs
            drawMetaballs();

            // Add glass reflection
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(lampX + 10, lampY + 10, lampWidth - 20, lampHeight - 20, 15);
            ctx.stroke();
            ctx.restore();

            requestAnimationFrame(animate);
        }

        animate();

        // ============================================
        // RESPONSIVE RESIZE
        // ============================================
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>