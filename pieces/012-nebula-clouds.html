<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="@wisdomabioye">
    <meta name="description" content="Art Series #012 - nebula-clouds">
    <meta name="created" content="2025-11-05">
    <title>nebula-clouds | Art Series #012</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        /**
         * Art Series #012
         * Title: nebula-clouds
         * Author: @wisdomabioye
         * Created: 2025-11-05
         * Description: Colorful nebula clouds with particles, stars, and flowing cosmic gas
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ============================================
        // MAIN ANIMATION CODE
        // ============================================

        let time = 0;

        // Simple noise function
        function noise(x, y, z) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            const Z = Math.floor(z) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);

            const u = x * x * x * (x * (x * 6 - 15) + 10);
            const v = y * y * y * (y * (y * 6 - 15) + 10);
            const w = z * z * z * (z * (z * 6 - 15) + 10);

            const A = (X + Y + Z) % 255;
            const B = (X + Y + Z + 1) % 255;

            return (A * (1 - u) + B * u) * (1 - v) +
                   ((A + 1) * (1 - u) + (B + 1) * u) * v;
        }

        // Nebula particle class
        class NebulaParticle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.baseX = this.x;
                this.baseY = this.y;
                this.size = Math.random() * 60 + 30;
                this.speedX = (Math.random() - 0.5) * 0.3;
                this.speedY = (Math.random() - 0.5) * 0.3;

                // Color regions - create different nebula colors
                const colorType = Math.random();
                if (colorType < 0.33) {
                    // Purple nebula
                    this.color = {
                        r: 150 + Math.random() * 50,
                        g: 50 + Math.random() * 50,
                        b: 200 + Math.random() * 55
                    };
                } else if (colorType < 0.66) {
                    // Pink nebula
                    this.color = {
                        r: 200 + Math.random() * 55,
                        g: 80 + Math.random() * 50,
                        b: 150 + Math.random() * 50
                    };
                } else {
                    // Blue nebula
                    this.color = {
                        r: 50 + Math.random() * 50,
                        g: 100 + Math.random() * 50,
                        b: 200 + Math.random() * 55
                    };
                }

                this.alpha = Math.random() * 0.3 + 0.1;
                this.noiseOffsetX = Math.random() * 1000;
                this.noiseOffsetY = Math.random() * 1000;
            }

            update(time) {
                // Add noise-based movement
                const noiseX = noise(this.baseX * 0.001 + time * 0.0002, this.noiseOffsetX, time * 0.0001);
                const noiseY = noise(this.baseY * 0.001 + time * 0.0002, this.noiseOffsetY, time * 0.0001);

                this.x = this.baseX + (noiseX - 128) * 2 + this.speedX * time;
                this.y = this.baseY + (noiseY - 128) * 2 + this.speedY * time;

                // Wrap around
                if (this.x < -this.size) this.baseX += canvas.width + this.size * 2;
                if (this.x > canvas.width + this.size) this.baseX -= canvas.width + this.size * 2;
                if (this.y < -this.size) this.baseY += canvas.height + this.size * 2;
                if (this.y > canvas.height + this.size) this.baseY -= canvas.height + this.size * 2;
            }

            draw() {
                ctx.save();

                // Create radial gradient for nebula cloud
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size
                );

                gradient.addColorStop(0, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.alpha})`);
                gradient.addColorStop(0.4, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.alpha * 0.6})`);
                gradient.addColorStop(0.7, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.alpha * 0.3})`);
                gradient.addColorStop(1, `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0)`);

                ctx.fillStyle = gradient;
                ctx.globalCompositeOperation = 'screen'; // Additive blending
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // Star class
        class Star {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2;
                this.alpha = Math.random() * 0.8 + 0.2;
                this.twinkleSpeed = Math.random() * 0.02 + 0.01;
                this.twinklePhase = Math.random() * Math.PI * 2;
            }

            update(time) {
                this.twinklePhase += this.twinkleSpeed;
            }

            draw() {
                const twinkle = Math.sin(this.twinklePhase) * 0.3 + 0.7;

                ctx.save();
                ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha * twinkle})`;
                ctx.shadowBlur = this.size * 3;
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Dust particle class (smaller, faster moving particles)
        class DustParticle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 0.5;
                this.speedX = (Math.random() - 0.5) * 0.5;
                this.speedY = (Math.random() - 0.5) * 0.5;
                this.alpha = Math.random() * 0.4 + 0.2;

                // Warm dust colors
                const warmth = Math.random();
                this.color = {
                    r: 200 + Math.random() * 55,
                    g: 150 + warmth * 50,
                    b: 100 + warmth * 100
                };
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;

                if (this.x < 0) this.x = canvas.width;
                if (this.x > canvas.width) this.x = 0;
                if (this.y < 0) this.y = canvas.height;
                if (this.y > canvas.height) this.y = 0;
            }

            draw() {
                ctx.save();
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.alpha})`;
                ctx.globalCompositeOperation = 'screen';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Create nebula particles
        const nebulaParticles = [];
        for (let i = 0; i < 30; i++) {
            nebulaParticles.push(new NebulaParticle());
        }

        // Create stars
        const stars = [];
        for (let i = 0; i < 200; i++) {
            stars.push(new Star());
        }

        // Create dust particles
        const dustParticles = [];
        for (let i = 0; i < 100; i++) {
            dustParticles.push(new DustParticle());
        }



        // ============================================
        // ANIMATION LOOP
        // ============================================
        
        function animate() {
            // Clear with deep space black
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            time += 1;

            // Draw stars (background layer)
            for (let star of stars) {
                star.update(time);
                star.draw();
            }

            // Draw nebula clouds (middle layer) with blending
            ctx.globalCompositeOperation = 'screen';
            for (let particle of nebulaParticles) {
                particle.update(time);
                particle.draw();
            }
            ctx.globalCompositeOperation = 'source-over';

            // Draw dust particles (foreground layer)
            for (let dust of dustParticles) {
                dust.update();
                dust.draw();
            }

            requestAnimationFrame(animate);
        }

        animate();

        // ============================================
        // RESPONSIVE RESIZE
        // ============================================
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html>